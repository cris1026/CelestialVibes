/* autogenerated by Processing revision 1293 on 2023-09-30 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import peasy.*;
import oscP5.*;
import netP5.*;
import supercollider.*;
import java.lang.Math;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class CelestialVibesPDE extends PApplet {







Octree octree;
ArrayList<Particle> globalParticles;
ArrayList<Particle> globalSystems;
PVector centerOfMass;
float G = 2;
int nPlan = 100;
PVector position;
float size;
int octreeCap = 5;
int depth;
float sizeMax;
int count;
ArrayList<Octree> leaves;
boolean drawTreeFlag = false;
float threshold = 0.5f;
float forceConstrain = 5;
float massone = 50000;
float minMass = 10, maxMass = 30; // mass limits in the planets creation

ControlP5 cp5;

//OSC
OscP5 oscP5;
NetAddress myRemoteLocation;
ArrayList<Float> nLead_old;
//NetAddress bassLocation;

PeasyCam cam;
float current_rot_X = 0;
float current_rot_Y = 0;
float current_zoom = 5000;
float scale = 1;
float current_pan_x=0;
float current_pan_y=0;
float xPan = 0;
float yPan = 0;

PFont f, f2, f3, f4, f5;
float textScale = 0;
float textTarget = 128;

PImage[] img = new PImage[15];
PImage[] img_loading = new PImage[6];
PShape[] hand = new PShape[13];
PShape[] mixerHand = new PShape[4];
int infoHeight = 50;
boolean overInfo = false;
boolean infoActive = false;
boolean overX = false;

// PROBABILITY
HashMap<String, Integer> probInterval = new HashMap<String, Integer>();
HashMap<String, Integer> probWin = new HashMap<String, Integer>();
HashMap<Integer, Integer> notes = new HashMap<Integer, Integer>();
HashMap<Integer, String> scaleName = new HashMap<Integer, String>();
HashMap<Integer, String> scaleType = new HashMap<Integer, String>();
HashMap<Integer, String> midiToNote = new HashMap<Integer, String>();
int rootNote = 0;
int foundScale = 0; // 0: no scale found || 1: Major || 2: Minor
int scaleCounter = 0; // se arriva a 2 significa che in un impatto PP sono state definite entrmbe le scale --> l'impatto non avviene

//Loading Screen
int startPhase = 0;
int checkpoint = 0;
boolean started = false;
boolean oneTime = true;
boolean loaded = false;
PImage img_home, img_load;
boolean firstTime = true;
boolean octreeDrawable = false;
int Y_AXIS = 1;
int X_AXIS = 2;

//PAN ZOOM ROTATION utility
int pan_count = 0;

// System (chords) visualization
boolean highlighting = false;
int chordPosX = 30;
int chordPosY = 30;
int chordsWidth = 300;
int chordsHeight = 210;
int linePosY = 70;
int chordCount = 0;
PImage sx_arr, dx_arr, sx_arr_on, dx_arr_on;
boolean sxFlag = false;
boolean dxFlag = false;
boolean firstChord = false;
int sxCount = 0;
int dxCount = 0;

public void setup() {
  frameRate(30);
  /* size commented out by preprocessor */;
  surface.setLocation(displayWidth/2 - width/2, displayHeight/2 - height/2 - 50);

  cam = new PeasyCam(this, 850);
  cam.setMinimumDistance(200);
  cam.setMaximumDistance(5000);

  //OSC Init
  oscP5 = new OscP5(this, 12000); // start OSC and listen port ...
  myRemoteLocation = new NetAddress("127.0.0.1", 57120);
  cp5 = new ControlP5(this);

  img_home = loadImage("title.png");
  img_load = loadImage("loading.png");
  img_loading[0] = loadImage("0.png");
  img_loading[1] = loadImage("20.png");
  img_loading[2] = loadImage("40.png");
  img_loading[3] = loadImage("60.png");
  img_loading[4] = loadImage("80.png");
  img_loading[5] = loadImage("100.png");
}


public void draw() {
  ////////////////////////////////////////////
  // LOADING
  ////////////////////////////////////////////
  switch(startPhase)
  {
  case 0: //Strat the setup
    thread("init_page");
    startPhase++;
    return;
  case 1: //During the setup
    showLoading();
    return;
  case 2: //Home page
    homePage();
    return;
  }


  ////////////////////////////////////////////
  // MAIN
  ////////////////////////////////////////////

  surface.setTitle("Celestial Vibes " + nf(frameRate, 0, 1) + " P: " + globalParticles.size() + " S: " + globalSystems.size());

  img[13].resize(width, height);
  float coordMax = 0;
  float tempCoordMax = 0;
  PVector posMax = new PVector();
  float massMax = 0;
  Particle tempParticle = new Particle(0, 0, 0, 0, -1, -1, -1, -1);
  background(img[13]);
  lights();

  centerOfMass = octree.calculateCenterOfMass().copy();

  for (Particle particle : globalParticles) {

    octree.calculateForce(particle, threshold);
    particle.update();

    posMax = PVector.sub(particle.position, octree.position);
    coordMax = max(abs(posMax.x), abs(posMax.y), abs(posMax.z));

    if (coordMax > tempCoordMax) {
      tempParticle = particle;
      tempCoordMax = coordMax;
      massMax = particle.mass;
    }
  }
  sizeMax = 2*(tempCoordMax + massMax);
  if (sizeMax > 5000) {
    globalParticles.remove(tempParticle);
    if (tempParticle.type != 1) {
      globalSystems.remove(tempParticle);
    }
  }


  octree = new Octree(centerOfMass, octreeCap, sizeMax);
  for (Particle p : globalParticles) {
    octree.addParticle(p);
    p.display();
  }

  octree.leavesList();
  octree.calculateImpact(leaves);

  if (centerOfMass.mag()>100) {
    //println("Troppo Distantee");
    for (Particle p : globalParticles) {
      PVector force = centerOfMass.copy();
      force.setMag(10/centerOfMass.mag());
      p.applyBruteForce(force.mult(-1));
    }
  }

  if (drawTreeFlag) {

    for (Octree leaf : leaves) {
      leaf.drawOctree();
    }

    push();
    stroke(255, 255, 0);
    strokeWeight(2);
    line(octree.position.x, octree.position.y, octree.position.z, tempParticle.position.x, tempParticle.position.y, tempParticle.position.z);
    pop();
    //println("size: " + sizeMax);
  }

  leaves = new ArrayList<Octree>();

  if (foundScale != 0) {

    cam.beginHUD();
    if (textScale<127) {
      textScale = lerp(textScale, textTarget, 0.1f);
    } else {
      textScale = textTarget;
    }

    textFont(f);
    textSize(textScale);
    textAlign(CENTER);
    text(scaleName.get(rootNote), width - 140, height -70);
    textSize(textScale/5);
    text(scaleType.get(foundScale), width - 138, height -40);
    cam.endHUD();
  }

  current_rot_X = lerp(current_rot_X, angle_X, 0.05f);
  current_rot_Y = lerp(current_rot_Y, angle_Y, 0.05f);
  cam.rotateX(current_rot_X);
  cam.rotateY(current_rot_Y);
  angle_X = 0;
  angle_Y = 0;

  current_pan_x = lerp(current_pan_x, Pan_X, 0.05f);
  current_pan_y = lerp(current_pan_y, Pan_Y, 0.05f);
  cam.pan(current_pan_x, current_pan_y);

  Pan_X=0;
  Pan_Y=0;

  // CONTROL P5 SLIDERS
  bassSli.update();
  padSli.update();
  arpSli.update();
  masterSli.update();

  cam.beginHUD();
  cp5.draw();


  // Hand Detection rectangle
  push();
  translate(width-140, height-320);
  fill(0, 190);
  stroke(255);
  strokeWeight(4);
  rect(-90, 0, 180, 130, 0, 0, 20, 20);
  line(0, 30, 0, 130);
  line(-90, 30, 90, 30);
  fill(255);
  shapeMode(CENTER);

  shape(hand[1], 45, 80, 60, 63);
  shape(hand[2], -45, 80, 60, 63);
  shape(hand[3], 45, 80, 60, 63);
  shape(hand[4], -45, 80, 60, 63);
  shape(hand[5], 45, 80, 60, 63);
  shape(hand[6], -45, 80, 60, 63);
  shape(hand[7], 45, 80, 60, 63);
  shape(hand[8], -45, 80, 60, 63);
  shape(hand[9], 45, 80, 60, 63);
  shape(hand[10], -45, 80, 60, 63);
  shape(hand[11], 45, 80, 60, 63);
  shape(hand[12], -45, 80, 60, 63);


  textFont(f5);
  textAlign(CENTER, CENTER);
  text("HAND DETECTION", 0, 14);

  pop();

  shape(mixerHand[0], masterSli.getPosition()[0], height - 50, masterSli.getWidth(), 31);
  shape(mixerHand[1], bassSli.getPosition()[0], height - 50, bassSli.getWidth(), 31);
  shape(mixerHand[2], padSli.getPosition()[0], height - 50, padSli.getWidth(), 31);
  shape(mixerHand[3], arpSli.getPosition()[0], height - 50, arpSli.getWidth(), 31);

  cam.endHUD();

  cam.setMouseControlled(true);
  //if (drumSli.isInside() || bassSli.isInside() || padSli.isInside() || arpSli.isInside() || masterSli.isInside() ) {
  if (bassSli.isInside() || padSli.isInside() || arpSli.isInside() || masterSli.isInside() ) {
    cam.setMouseControlled(false);
  }


  // INFO ON HAND CONTROLS
  if (infoActive) {

    cam.beginHUD();
    push();
    fill(0, 200);
    stroke(255);
    rect(width/2 - 700, infoHeight, 1400, 400);
    pop();

    textFont(f4);
    textSize(50);
    text("Useful informations", width/2, infoHeight + 50);
    textSize(30);
    text("You can use your hands to control the system in different ways:", width/2, infoHeight + 100);
    text("1. By touching the index finger and thumb of the RIGHT hand you can control the ROTATION", width/2, infoHeight + 150);
    text("2. By touching the index finger and thumb of the LEFT hand you can control the PAN", width/2, infoHeight + 190);
    text("3. By combining 1. and 2. and moving BOTH HANDS you can ZOOM in and out", width/2, infoHeight + 230);
    text("4. Doing different numbers with the RIGHT hand (e.g. index up for 1) you are selecting", width/2, infoHeight + 270);
    text("different sliders. In the meanwhile, touching index and thumb of the LEFT hand and", width/2, infoHeight + 310);
    text("moving it up and down you can control the level of the desired slider.", width/2, infoHeight + 350);

    cam.endHUD();
  } else {
    cam.beginHUD();
    image(img[14], width - 250, 30, 200, 85);
    cam.endHUD();
  }

  // SEND ROOT NOTE TO BASS
  RootOsc();

  if (highlighting) {
    cam.beginHUD();
    push();
    fill(0, 190);
    stroke(255);
    strokeWeight(4);
    rect(chordPosX, chordPosY, chordsWidth, chordsHeight, 0, 0, 20, 20);
    line(chordPosX, chordPosY + linePosY, chordPosX + chordsWidth, chordPosY + linePosY);
    line(chordPosX, chordPosY + linePosY*2, chordPosX + chordsWidth, chordPosY + linePosY*2);
    line(chordPosX + chordsWidth/2, chordPosY + linePosY*2, chordPosX + chordsWidth/2, chordPosY + chordsHeight);
    pop();

    textAlign(CENTER, CENTER);
    textFont(f4);
    textSize(50);
    text("Chords List", chordPosX + chordsWidth/2, chordPosY + linePosY/2 - 5);

    if (globalSystems.size() != 0) {
      String chord = " ";
      for (int n=0; n<globalSystems.get(chordCount).getNotes().size(); n++) {
        chord = chord + midiToNote.get(globalSystems.get(chordCount).getNotes().get(n)) + "  ";
      }

      textSize(30);
      textAlign(CENTER, CENTER);
      text((chordCount+1) + ". " +chord, chordPosX + chordsWidth/2, chordPosY + linePosY*1.5f - 3);
    }
    //textAlign(CENTER, CENTER);
    //text("D: <=      => :D", chordPosX + chordsWidth/2, chordPosY + linePosY*2.5);

    // LEFT ARROW
    if (sxFlag && sxCount < 10) {
      imageMode(CENTER);
      image(sx_arr_on, chordPosX + chordsWidth/4, chordPosY + linePosY*2.5f, 30, 30);
      sxCount ++;
    } else {
      if (sxFlag) {
        sxFlag = false;
      }
      if (sxCount != 0) {
        sxCount = 0;
      }
      imageMode(CENTER);
      image(sx_arr, chordPosX + chordsWidth/4, chordPosY + linePosY*2.5f, 30, 30);
    }

    // RIGHT ARROW
    if (dxFlag && dxCount < 5) {
      imageMode(CENTER);
      image(dx_arr_on, chordPosX + chordsWidth*3/4, chordPosY + linePosY*2.5f, 30, 30);
      dxCount ++;
    } else {
      if (dxFlag) {
        dxFlag = false;
      }
      if (dxCount != 0) {
        dxCount = 0;
      }
      imageMode(CENTER);
      image(dx_arr, chordPosX + chordsWidth*3/4, chordPosY + linePosY*2.5f, 30, 30);
    }
    cam.endHUD();
    imageMode(CORNER);

    if (globalSystems.size() != 0) {
      globalSystems.get(chordCount).higlight();
      if (firstChord) {
        cam.lookAt(globalSystems.get(chordCount).position.x, globalSystems.get(chordCount).position.y, globalSystems.get(chordCount).position.z, (double) 550, 150);
        firstChord = false;
      }
      if (dxCount == 1 || sxCount == 1) {
        cam.lookAt(globalSystems.get(chordCount).position.x, globalSystems.get(chordCount).position.y, globalSystems.get(chordCount).position.z, (double) 550, 150);
      } else {
        cam.lookAt(globalSystems.get(chordCount).position.x, globalSystems.get(chordCount).position.y, globalSystems.get(chordCount).position.z, (double) 550, 0);
        cam.rotateX(PI/500);
        cam.rotateY(PI/500);
      }
    }
  }
}

public void mouseClicked() {
  if (mouseButton == RIGHT) {
    if (started) {
      drawTreeFlag = !drawTreeFlag;
    }
  }
}

public void keyPressed() {
  if (key == 'i') {
    infoActive = true;
    hand[0].setVisible(false);
  }
  if (key == 'r' && started) {
    println("reset");

    OscMessage msg = new OscMessage("/reset");
    msg.add("RESET!");
    oscP5.send(msg, myRemoteLocation);

    started = false;
    oneTime = true;
    drawTreeFlag = false;
    infoActive = false;
    octreeDrawable = false;
    textScale = 0;
    rootNote = 0;
    foundScale = 0; // 0: no scale found || 1: Major || 2: Minor
    scaleCounter = 0; // se arriva a 2 significa che in un impatto PP sono state definite entrmbe le scale --> l'impatto non avviene
    cp5 = new ControlP5(this);
    background(0);


    cam.reset();
    startPhase = 0;
  }
  if (key == 'c') {
    highlighting = true;
    firstChord = true;
  }
  if (keyCode == RIGHT && highlighting) {
    dxFlag = true;
    if (globalSystems.size() > chordCount+1) {
      chordCount++;
    } else {
      chordCount = 0;
    }
  }
  if (keyCode == LEFT && highlighting) {
    sxFlag = true;
    if (chordCount!=0) {
      chordCount--;
    } else {
      chordCount = globalSystems.size()-1;
    }
  }
}

public void keyReleased() {
  if (key == 'i') {
    infoActive = false;
    hand[0].setVisible(true);
  }
  if (key == 'c') {
    highlighting = false;
    chordCount = 0;
    cam.reset(2000);
    cam.setDistance(5000, 2000);
  }
}

public boolean overCircle(int x, int y, int diameter) {
  float disX = x - mouseX;
  float disY = y - mouseY;
  if (sqrt(sq(disX) + sq(disY)) < diameter/2 ) {
    return true;
  } else {
    return false;
  }
}

public boolean overRect(int x, int y, int w, int h) {
  if (mouseX >= x && mouseX <= x+w &&
    mouseY >= y && mouseY <= y+h) {
    return true;
  } else {
    return false;
  }
}

float startAngle_X;
float startAngle_Y;
float startPan_X;
float startPan_Y;
float start_zoom;

float oldX = 0;
float oldY = 0;
float oldPanX = 0;
float oldPanY = 0;

float old_inc_X = 0;
float old_inc_Y = 0;
float old_inc_Pan_X = 0;
float old_inc_Pan_Y = 0;
float old_inc_zoom = 0;

float maxIncrement = radians(100);
float angle_X = 0;
float angle_Y = 0;
float Pan_X;
float Pan_Y;
float zoom;


public void oscEvent(OscMessage theOscMessage) {
  /* print the address pattern and the typetag of the received OscMessage */
  print("### received an osc message.");
  print(" || addrpattern: "+theOscMessage.addrPattern());
  println(" || typetag:"+theOscMessage.typetag());

  // PSS ROTATION OSC MESSAGE
  if (theOscMessage.checkAddrPattern("/PSS_rotation_start")==true) {
    if (theOscMessage.checkTypetag("ff")) {

      float x = theOscMessage.get(0).floatValue();
      float y = theOscMessage.get(1).floatValue();

      float inc_X = map(x, 0, 1, -2*PI, 2*PI);
      float inc_Y = map(y, 0, 1, -2*PI, 2*PI);

      startAngle_X = inc_X;
      startAngle_Y = inc_Y;

      old_inc_X = 0;
      old_inc_Y = 0;

      angle_Y = 0;
      angle_X = 0;
    }
  } else if (theOscMessage.checkAddrPattern("/PSS_rotation")==true) {
    if (theOscMessage.checkTypetag("ff")) {

      float x = theOscMessage.get(0).floatValue();
      float y = theOscMessage.get(1).floatValue();

      float inc_X = map(x, 0, 1, -2*PI, 2*PI);
      float inc_Y = map(y, 0, 1, -2*PI, 2*PI);

      angle_Y = -(inc_X - old_inc_X - startAngle_X);
      angle_X = inc_Y - old_inc_Y - startAngle_Y;

      old_inc_X = inc_X - startAngle_X;
      old_inc_Y = inc_Y - startAngle_Y;
    }
  }

  // PSS PAN OSC MESSAGE
  if (theOscMessage.checkAddrPattern("/PSS_pan_start")==true) {
    if (theOscMessage.checkTypetag("ff")) {

      float x = theOscMessage.get(0).floatValue();
      float y = theOscMessage.get(1).floatValue();

      float inc_Pan_X = map(x, 0, 1, -1500, 1500);
      float inc_Pan_Y = map(y, 0, 1, -1500, 1500);

      startPan_X = inc_Pan_X;
      startPan_Y = inc_Pan_Y;

      old_inc_Pan_X = 0;
      old_inc_Pan_Y = 0;

      Pan_X = 0;
      Pan_Y = 0;
    }
  } else if (theOscMessage.checkAddrPattern("/PSS_pan")==true) {
    if (theOscMessage.checkTypetag("ff")) {

      float x = theOscMessage.get(0).floatValue();
      float y = theOscMessage.get(1).floatValue();

      float inc_Pan_X = map(x, 0, 1, -1500, 1500);
      float inc_Pan_Y = map(y, 0, 1, -1500, 1500);

      Pan_X = -(inc_Pan_X - old_inc_Pan_X - startPan_X);
      Pan_Y = -(inc_Pan_Y - old_inc_Pan_Y - startPan_Y);

      old_inc_Pan_X = inc_Pan_X - startPan_X;
      old_inc_Pan_Y = inc_Pan_Y - startPan_Y;
    }
  }

  // PSS ZOOM OSC MESSAGE
  if (theOscMessage.checkAddrPattern("/PSS_zoom_start")==true) {
    if (theOscMessage.checkTypetag("f")) {

      float x = theOscMessage.get(0).floatValue();
      x = constrain(x, 0.1f, 0.55f);
      float inc_zoom = map(x, 0.1f, 0.55f, 0, 4000);
      start_zoom = inc_zoom;
      old_inc_zoom = 0;
      zoom = inc_zoom - old_inc_zoom - start_zoom;
      cam.setDistance(cam.getDistance() + zoom);
    }
  } else if (theOscMessage.checkAddrPattern("/PSS_zoom")==true) {
    if (theOscMessage.checkTypetag("f")) {

      float x = theOscMessage.get(0).floatValue();
      x = constrain(x, 0.1f, 0.55f);
      float inc_zoom = map(x, 0.1f, 0.55f, 0, 4000);
      zoom = -(inc_zoom - old_inc_zoom - start_zoom);
      old_inc_zoom = inc_zoom - start_zoom;
      cam.setDistance(cam.getDistance() + zoom, 1000);
    }
  }

  // MIXER MASTER CHANGING OSC MESSAGE
  if (theOscMessage.checkAddrPattern("/mixer_1_changing")==true) {
    if (theOscMessage.checkTypetag("f")) {

      float y = theOscMessage.get(0).floatValue();
      float mix1_val = constrain(y, 0.25f, 0.75f);
      mix1_val= map(mix1_val, 0.25f, 0.75f, 1.5f, 0.0001f);
      masterSli.setValue(mix1_val);
      OscMessage msg = new OscMessage("/masterFader");
      msg.add(mix1_val);
      oscP5.send(msg, myRemoteLocation);
    }
  }

  // MIXER BASS CHANGING OSC MESSAGE
  if (theOscMessage.checkAddrPattern("/mixer_2_changing")==true) {
    if (theOscMessage.checkTypetag("f")) {

      float y = theOscMessage.get(0).floatValue();
      float mix1_val = constrain(y, 0.25f, 0.75f);
      mix1_val= map(mix1_val, 0.25f, 0.75f, 1.5f, 0.0001f);
      bassSli.setValue(mix1_val);
      OscMessage msg = new OscMessage("/bassFader");
      msg.add(mix1_val);
      oscP5.send(msg, myRemoteLocation);
    }
  }

  // MIXER PAD CHANGING OSC MESSAGE
  if (theOscMessage.checkAddrPattern("/mixer_3_changing")==true) {
    if (theOscMessage.checkTypetag("f")) {

      float y = theOscMessage.get(0).floatValue();
      float mix1_val = constrain(y, 0.25f, 0.75f);
      mix1_val= map(mix1_val, 0.25f, 0.75f, 1.5f, 0.0001f);
      padSli.setValue(mix1_val);
      OscMessage msg = new OscMessage("/padFader");
      msg.add(mix1_val);
      oscP5.send(msg, myRemoteLocation);
    }
  }

  // MIXER PAD CHANGING OSC MESSAGE
  if (theOscMessage.checkAddrPattern("/mixer_4_changing")==true) {
    if (theOscMessage.checkTypetag("f")) {

      float y = theOscMessage.get(0).floatValue();
      float mix1_val = constrain(y, 0.25f, 0.75f);
      mix1_val= map(mix1_val, 0.25f, 0.75f, 1.5f, 0.0001f);
      arpSli.setValue(mix1_val);
      OscMessage msg = new OscMessage("/arpFader");
      msg.add(mix1_val);
      oscP5.send(msg, myRemoteLocation);
    }
  }

  // HAND DETECTION IMAGES OSC MESSAGE
  if (theOscMessage.checkAddrPattern("/gesture")==true) {
    if (theOscMessage.checkTypetag("")) {
      hand[1].setVisible(false);
      hand[2].setVisible(false);
      hand[3].setFill(color(100, 100, 100));
      hand[4].setFill(color(100, 100, 100));
      hand[3].setVisible(true);
      hand[4].setVisible(true);
      hand[5].setVisible(false);
      hand[6].setVisible(false);
      hand[7].setVisible(false);
      hand[8].setVisible(false);
      hand[9].setVisible(false);
      hand[10].setVisible(false);
      hand[11].setVisible(false);
      hand[12].setVisible(false);
    } else if (theOscMessage.checkTypetag("s")) {
      String[] msg = new String[1];
      msg[0] = theOscMessage.get(0).toString();
      setHandVisible(msg);
    } else if (theOscMessage.checkTypetag("ss")) {
      String[] msg = new String[2];
      msg[0] = theOscMessage.get(0).toString();
      msg[1] = theOscMessage.get(1).toString();
      setHandVisible(msg);
    }
  }

  if (theOscMessage.checkAddrPattern("/EXIT")==true) {
    OscMessage msg = new OscMessage("/exit");
    oscP5.send(msg, myRemoteLocation);
    exit();
  }
}

public void setHandVisible(String[] osc) {
  if (osc.length == 1) {
    if (osc[0].charAt(0) == 'R') {
      hand[2].setVisible(false);
      hand[4].setFill(color(100, 100, 100));
      hand[4].setVisible(true);
      hand[6].setVisible(false);
      hand[8].setVisible(false);
      hand[10].setVisible(false);
      hand[12].setVisible(false);
    } else if (osc[0].charAt(0) == 'L') {
      hand[1].setVisible(false);
      hand[3].setFill(color(100, 100, 100));
      hand[3].setVisible(true);
      hand[5].setVisible(false);
      hand[7].setVisible(false);
      hand[9].setVisible(false);
      hand[11].setVisible(false);
    }
  }
  for (String s : osc) {
    if (s.charAt(0) == 'R') {
      if (s.length() == 1) {
        hand[1].setVisible(false);
        hand[3].setFill(color(250, 255, 0));
        hand[3].setVisible(true);
        hand[5].setVisible(false);
        hand[7].setVisible(false);
        hand[9].setVisible(false);
        hand[11].setVisible(false);
      } else {
        switch(s.charAt(1)) {
        case '1':
          hand[1].setVisible(false);
          hand[3].setVisible(false);
          hand[5].setVisible(true);
          hand[7].setVisible(false);
          hand[9].setVisible(false);
          hand[11].setVisible(false);
          break;
        case '2':
          hand[1].setVisible(false);
          hand[3].setVisible(false);
          hand[5].setVisible(false);
          hand[7].setVisible(true);
          hand[9].setVisible(false);
          hand[11].setVisible(false);
          break;
        case '3':
          hand[1].setVisible(false);
          hand[3].setVisible(false);
          hand[5].setVisible(false);
          hand[7].setVisible(false);
          hand[9].setVisible(true);
          hand[11].setVisible(false);
          break;
        case '4':
          hand[1].setVisible(false);
          hand[3].setVisible(false);
          hand[5].setVisible(false);
          hand[7].setVisible(false);
          hand[9].setVisible(false);
          hand[11].setVisible(true);
          break;
        case 'O':
          hand[1].setVisible(true);
          hand[3].setVisible(false);
          hand[5].setVisible(false);
          hand[7].setVisible(false);
          hand[9].setVisible(false);
          hand[11].setVisible(false);
          break;
        }
      }
    } else if (s.charAt(0) == 'L') {
      if (s.length() == 1) {
        hand[2].setVisible(false);
        hand[4].setFill(color(250, 255, 0));
        hand[4].setVisible(true);
        hand[6].setVisible(false);
        hand[8].setVisible(false);
        hand[10].setVisible(false);
        hand[12].setVisible(false);
      } else {
        switch(s.charAt(1)) {
        case '1':
          hand[2].setVisible(false);
          hand[4].setVisible(false);
          hand[6].setVisible(true);
          hand[8].setVisible(false);
          hand[10].setVisible(false);
          hand[12].setVisible(false);
          break;
        case '2':
          hand[2].setVisible(false);
          hand[4].setVisible(false);
          hand[6].setVisible(false);
          hand[8].setVisible(true);
          hand[10].setVisible(false);
          hand[12].setVisible(false);
          break;
        case '3':
          hand[2].setVisible(false);
          hand[4].setVisible(false);
          hand[6].setVisible(false);
          hand[8].setVisible(false);
          hand[10].setVisible(true);
          hand[12].setVisible(false);
          break;
        case '4':
          hand[2].setVisible(false);
          hand[4].setVisible(false);
          hand[6].setVisible(false);
          hand[8].setVisible(false);
          hand[10].setVisible(false);
          hand[12].setVisible(true);
          break;
        case 'O':
          hand[2].setVisible(true);
          hand[4].setVisible(false);
          hand[6].setVisible(false);
          hand[8].setVisible(false);
          hand[10].setVisible(false);
          hand[12].setVisible(false);
          break;
        }
      }
    }
  }
}

public void RootOsc() {
  if (rootNote!=0) {
    int midi = notes.get(rootNote);
    String str = Integer.toString(midi-24);
    OscMessage msg = new OscMessage("/bass");
    msg.add(str);
    oscP5.send(msg, myRemoteLocation);
  }
}


int muteColor = unhex("ffff7d00");
int soloColor = unhex("ffffdd00");
int bgColor = unhex("ff2D4A54");

Fader bassSli, padSli, arpSli, masterSli;

float[] volumes = {1, 1, 1, 1, 1};

float[] channelVolumes = {1, 1, 1, 1, 1};

int sliderPaddingX = 60;
int labelPaddingY = 10;
int sliderPaddingY = 40;
int buttonPaddingY = 10;


public void setupMixer() {
  //PFont.list();
  int sliderPosY = height - 200;
  f2 = createFont("Arial", 25, true);
  f3 = createFont("Arial", 20, true);

  bassSli = new Fader("Bass", 1);
  padSli = new Fader("Pad", 2);
  arpSli = new Fader("Arp", 3);
  masterSli = new Fader("Master", 4);
  
  masterSli.setPosition(sliderPaddingX, sliderPosY);
  bassSli.setPosition((int)masterSli.getPosition()[0]+bassSli.getWidth()+sliderPaddingX*2, sliderPosY);
  padSli.setPosition((int)bassSli.getPosition()[0]+bassSli.getWidth()+sliderPaddingX, sliderPosY);
  arpSli.setPosition((int)padSli.getPosition()[0]+padSli.getWidth()+sliderPaddingX, sliderPosY);
  
  cp5.setAutoDraw(false);
}

public float sum(float[] a) {
  float sum=0;
  for (int i=0; i<a.length; i++) {
    sum = sum+a[i];
  }
  return sum;
}

public void showMixer() {
  bassSli.show();
  padSli.show();
  arpSli.show();
  masterSli.show();
};

public void hideMixer() {
  bassSli.hide();
  padSli.hide();
  arpSli.hide();
  masterSli.hide();
}

// MYFADER
class Fader {
  String name;
  Slider fader;
  float volume;
  int id;

  Fader(String theName, int theId) {
    id = theId;
    name = theName;
    fader = cp5.addSlider(name)
      .setSize(width/60, height/8)
      .setRange(0, 3)
      .setValue(2)
      .setSliderMode(Slider.FLEXIBLE)
      .setLabelVisible(false)
      .setColorForeground(unhex("ffff006d"))
      .setColorBackground(bgColor)
      ;
  }

  public float getVolume() {
    float val = cp5.getController(name).getValue();
    double vol =  20*Math.log10((double)map(val/2, 0, 3, 0.0001f, 3));
    float a = (float)vol;
    a = (float)round(a*100)/100;
    return a;
  }

  public int getWidth() {
    return cp5.getController(name).getWidth();
  }

  public int getHeight() {
    return cp5.getController(name).getHeight();
  }

  public float[] getPosition() {
    return cp5.getController(name).getPosition();
  }

  public void setPosition(int x0, int y0) {
    fader.setPosition(x0, y0);
  }

  public void setValue(float theVal) {
    double val = constrain(theVal, 0.0001f, 1.5f);
    volumes[id] = (float)val;

    double vol1 = 20*Math.log10(val);

    float vol = (float)vol1;
    vol = pow(10, vol/20);

    float faderVal = map(vol, 0, 1.5f, 0, 3);

    fader.setValue(faderVal);
  };

  public void update() {
    volumes[id] = pow(10, getVolume()/20);
    float xcenter = fader.getPosition()[0]+fader.getWidth()/2;
    String volume = String.valueOf(getVolume());

    if (fader.isVisible()) {
      cam.beginHUD();
      // Name Label
      textAlign(CENTER);
      fill(255);
      textFont(f2);
      textSize(25);
      text(name, xcenter, fader.getPosition()[1]-labelPaddingY);

      // Value label

      textFont(f3);
      textSize(18);
      text(volume + " dB", xcenter, fader.getPosition()[1]+fader.getHeight()+ sliderPaddingY/2);
      cam.endHUD();
    }
    setVolume();
  }

  public void show() {
    cp5.getController(name).setVisible(true);
  }

  public void hide() {
    cp5.getController(name).setVisible(false);
  }

  public boolean isInside() {
    return cp5.getController(name).isInside();
  }
  
  public void setVolume(){
      OscMessage msg = new OscMessage("/mixerFader");
      msg.add(name);
      msg.add(getVolume());
      oscP5.send(msg, myRemoteLocation);
  }
}
class Octree {
  PVector position;
  int capacity;
  float size;
  ArrayList<Particle> particles;
  Octree[] children;
  boolean divided;
  int col;
  float totalMass;
  PVector centerOfMass;

  Octree(PVector position, int capacity, float size) {
    this.position = position;
    this.size = size;
    this.capacity = capacity;
    particles = new ArrayList<Particle>();
    children = new Octree[8];
    this.divided = false;
    col = color(255);
    this.centerOfMass = new PVector();
    this.totalMass = 0;
  }


  public boolean contains(Particle particle) {
    float minX = position.x - size/2;
    float minY = position.y - size/2;
    float minZ = position.z - size/2;
    float maxX = position.x + size/2;
    float maxY = position.y + size/2;
    float maxZ = position.z + size/2;

    return particle.position.x >= minX && particle.position.x <= maxX &&
      particle.position.y >= minY && particle.position.y <= maxY &&
      particle.position.z >= minZ && particle.position.z <= maxZ;
  }


  public void subdivide() {
    float subSize = size / 2;
    float x = position.x;
    float y = position.y;
    float z = position.z;
    children[0] = new Octree(new PVector(x - subSize/2, y - subSize/2, z + subSize/2), capacity, subSize);
    children[1] = new Octree(new PVector(x + subSize/2, y - subSize/2, z + subSize/2), capacity, subSize);
    children[2] = new Octree(new PVector(x - subSize/2, y + subSize/2, z + subSize/2), capacity, subSize);
    children[3] = new Octree(new PVector(x + subSize/2, y + subSize/2, z + subSize/2), capacity, subSize);
    children[4] = new Octree(new PVector(x - subSize/2, y - subSize/2, z - subSize/2), capacity, subSize);
    children[5] = new Octree(new PVector(x + subSize/2, y - subSize/2, z - subSize/2), capacity, subSize);
    children[6] = new Octree(new PVector(x - subSize/2, y + subSize/2, z - subSize/2), capacity, subSize);
    children[7] = new Octree(new PVector(x + subSize/2, y + subSize/2, z - subSize/2), capacity, subSize);
    this.divided = true;
  }


  public int getIndex(Particle particle) {
    int index = -1;
    float x = position.x;
    float y = position.y;
    float z = position.z;
    boolean top = particle.position.y <= y;
    boolean bottom = particle.position.y > y;
    boolean left = particle.position.x <= x;
    boolean right = particle.position.x > x;
    boolean front = particle.position.z > z;
    boolean back = particle.position.z <= z;
    if (front && left && top) {
      index = 0;
    } else if (front && right && top) {
      index = 1;
    } else if (front && left && bottom) {
      index = 2;
    } else if (front && right && bottom) {
      index = 3;
    } else if (back && left && top) {
      index = 4;
    } else if (back && right && top) {
      index = 5;
    } else if (back && left && bottom) {
      index = 6;
    } else if (back && right && bottom) {
      index = 7;
    }
    return index;
  }


  public void addParticle(Particle particle) {
    if (!contains(particle)) {
      return;
    }

    particles.add(particle);

    if (particles.size() <= this.capacity && !this.divided) {
      return;
    } else {
      if (!this.divided) {
        subdivide();
      }
      for (int i = particles.size()-1; i>=0; i--) {
        Particle p = particles.get(i);
        int index = getIndex(p);
        if (index!=-1) {
          this.children[index].addParticle(p);
        }
        particles.remove(i);
      }
    }
  }


  public void leavesList() {
    if (this.divided) {
      for (Octree child : this.children) {
        child.leavesList();
      }
    } else {
      if (this.particles.size() > 0) leaves.add(this);
    }
  }

  public String typeOfImpact(Particle p1, Particle p2) {
    String strType = "";
    if (p1.type == 1 && p2.type == 1) {
      strType = "pp";
    } else if (p1.type == 1 && p2.type == 2) {
      strType = "ps";
    } else if (p1.type == 2 && p2.type == 1) {
      strType = "sp";
    } else if (p1.type != 1 && p2.type != 1) {
      strType = "ss";
    } else if (p1.type == 1 && p2.type == 3) {
      strType = "p_s3";
    } else if (p1.type == 3 && p2.type == 1) {
      strType = "s3_p";
    } else {
    }//println("Error on Impact");
    return strType;
  }

  public void impactPP(Particle Planet, Particle otherPlanet) {
    int note1 = Planet.note1;
    int note2 = otherPlanet.note1;
    PVector difference = new PVector();
    difference = PVector.sub(Planet.position, otherPlanet.position);
    difference.setMag(Planet.radius);
    PVector systemPos = PVector.add(Planet.position, difference);
    float systemMass = Planet.mass + otherPlanet.mass;
    Particle system = new Particle(systemPos.x, systemPos.y, systemPos.z, systemMass, 2, Planet.note1, otherPlanet.note1, -1);
    if (Planet.getMomentum().mag() >= otherPlanet.getMomentum().mag()) {
      system.velocity = Planet.velocity.copy();
    } else {
      system.velocity = otherPlanet.velocity.copy();
    }
    globalParticles.remove(Planet);
    globalParticles.remove(otherPlanet);
    globalParticles.add(system);
    globalSystems.add(system);
    systemsNotesOsc();
  }


  public void impactPS(Particle Planet, Particle System) {
    float newSystemMass = Planet.mass + System.mass;
    System.type = 3;
    System.note3 = Planet.note1;
    System.mass = newSystemMass;
    System.scale = 0;
    System.setGlobe3(Planet.note1);
    globalParticles.remove(Planet);
    systemsNotesOsc();
  }


  public void calculateImpact(ArrayList<Octree> leaves) {
    for (Octree oc : leaves) {
      for (Particle p : oc.particles) {
        for (Particle s : oc.particles) {
          if (oc.particles.indexOf(s) > oc.particles.indexOf(p)) {
            float distance = PVector.dist(p.position, s.position);
            float radiiSum = p.radius + s.radius;
            if (distance <= radiiSum && (p.impacting == false && s.impacting == false)) {
              p.impacting = true;
              s.impacting = true;
              String impactType = typeOfImpact(p, s);
              ArrayList<Float> nLead = new ArrayList<Float>();
              String strLead = "";
              OscMessage msgLead = new OscMessage("/lead_notes");
              switch (impactType) {
                // IMPACT PLANET - PLANET
              case "pp":
                int note1 = p.note1;
                int note2 = s.note1;
                // 1_st case: No system has been created ==> foundScale = 0; rootNote = 0;
                if (globalSystems.isEmpty()) {
                  int collision = probability(note1, note2);

                  if (collision != 0) { // A collision is happening
                    rootNote = collision;

                    //send OSC message with rootNote

                    // in the collision variable the winning note is stored
                    if (collision == p.note1) { //particle p has the winning note
                      impactPP(p, s);
                    } else { //particle s has the winning note
                      impactPP(s, p);
                    }
                  }
                }
                // 2_nd case: at least one system has been created and no scale has been found, but we have a rootNote != 0
                // ==> we have to check for the scale also in this situation
                else if (foundScale == 0) {
                  if (rootNoteSatisfied(note1, note2)) {
                    int collision = probability(note1, note2);

                    if (scaleCounter % 2 != 0) { //per evitare la collisione di due pianeti che rientrano in entrambe le scale
                      if (collision == p.note1) { //particle p has the winning note
                        impactPP(p, s);
                      } else if (collision == s.note1){ //particle s has the winning note
                        impactPP(s, p);
                      }
                    }
                  }
                }
                // 3_rd case: both scaleFound and rootNote are != 0
                else {
                  if (scaleSatisfied(note1, note2)) {
                    int collision = probability(note1, note2);
                    if (collision == p.note1) { //particle p has the winning note
                      impactPP(p, s);
                    } else if (collision == s.note1){ //particle s has the winning note
                      impactPP(s, p);
                    }
                  }
                }
                break;

                // IMPACT PLANET - SYSTEM
              case "ps":
                int note1_ps = s.note1;
                int note2_ps = s.note2;
                int note3_ps = p.note1;
                if (scaleSatisfiedForPS(note1_ps, note2_ps, note3_ps)) {
                  if (probabilityPS(note3_ps, note1_ps) && probabilityPS(note3_ps, note2_ps)) {
                    impactPS(p, s);
                  }
                }
                break;

                // IMPACT SYSTEM - PLANET
              case "sp":  // in this case the particle s is the planet and the particle p is the system
                int note1_sp = p.note1;
                int note2_sp = p.note2;
                int note3_sp = s.note1;
                if (scaleSatisfiedForPS(note1_sp, note2_sp, note3_sp)) {
                  if (probabilityPS(note3_sp, note1_sp) && probabilityPS(note3_sp, note2_sp)) {
                    impactPS(s, p);
                    //println(impactType);
                  }
                }
                break;

                // IMPACT SYSTEM - SYSTEM
              case "ss":
                break;
                
                // IMPACT PLANET - SYSTEM_3 (made by 3 planets)
              case "p_s3":
                nLead = s.getNotes();
                if (nLead_old.size() != 0) {
                  if (!nLead.equals(nLead_old)) {
                    nLead_old = nLead;
                    strLead = nLead.toString();
                    msgLead.add(strLead);
                    oscP5.send(msgLead, myRemoteLocation);
                  }
                } else {
                  nLead_old = nLead;
                  strLead = nLead.toString();
                  msgLead.add(strLead);
                  oscP5.send(msgLead, myRemoteLocation);
                }

                break;

                // IMPACT SYSTEM_3 - PLANET, this case can be linked to the previous
              case "s3_p":
                nLead = p.getNotes();
                if (nLead_old.size() != 0) {
                  if (!nLead.equals(nLead_old)) {
                    nLead_old = nLead;
                    strLead = nLead.toString();
                    msgLead.add(strLead);
                    oscP5.send(msgLead, myRemoteLocation);
                  }
                } else {
                  nLead_old = nLead;
                  strLead = nLead.toString();
                  msgLead.add(strLead);
                  oscP5.send(msgLead, myRemoteLocation);
                }

                break;
              default:
              }
            } else {
              p.impacting = false;
              s.impacting = false;
            }
          }
        }
      }
    }
  }


  public int probability(int note1, int note2) {
    int dist1 = abs(note2 - note1);
    int dist2 = 12 - dist1;
    int distWin;
    int firstNote;
    int winner;
    float ran = random(0, 100);

    if (ran <= probInterval.get(Integer.toString(dist1)+"&"+Integer.toString(dist2))) {
      if (note1 <= note2) {
        distWin = dist1;
        firstNote = note1;
        winner = winning(distWin, firstNote);
      } else {
        distWin = dist1;
        firstNote = note2;
        winner = winning(distWin, firstNote);
      }
    } else {
      if (note1 <= note2) {
        distWin = dist2;
        firstNote = note2;
        winner = winning(distWin, firstNote);
      } else {
        distWin = dist2;
        firstNote = note1;
        winner = winning(distWin, firstNote);
      }
    }
    // se c'è un vincitore e sia scala che rootNote non sono ancora state definita, entra in questo if
    // per vedere se la scala sarà definita dal primo impatto o meno
    if (winner != 0 && foundScale == 0 && rootNote == 0 && (distWin == 4 || distWin == 9 || distWin == 11)) {
      foundScale = 1; // Major
    }
    if (winner != 0 && foundScale == 0 && rootNote == 0 && (distWin == 3 || distWin == 8 || distWin == 10)) {
      foundScale = 2; // Minor
    }
    // se c'è un vincitore e la scala non è ancora state definita, ma la rootNote sì, entra in questo if
    if (winner != 0 && foundScale == 0 && rootNote != 0) {
      if ((note1 > rootNote && ( (note1 - rootNote) == 4 || (note1 - rootNote) == 9 ||  (note1 - rootNote) == 11 ) ) ||
        (note2 > rootNote && ( (note2 - rootNote) == 4 || (note2 - rootNote) == 9 ||  (note2 - rootNote) == 11 ) ) ||
        (note1 < rootNote && ( (note1 - rootNote) == (-8) || (note1 - rootNote) == (-3) ||  (note1 - rootNote) == (-1) ) ) ||
        (note2 < rootNote && ( (note2 - rootNote) == (-8) || (note2 - rootNote) == (-3) ||  (note2 - rootNote) == (-1) ) ) ) {
        foundScale = 1; // Major
        scaleCounter += 1;
      }
      if ((note1 > rootNote && ( (note1 - rootNote) == 3 || (note1 - rootNote) == 8 ||  (note1 - rootNote) == 10 ) ) ||
        (note2 > rootNote && ( (note2 - rootNote) == 3 || (note2 - rootNote) == 8 ||  (note2 - rootNote) == 10 ) ) ||
        (note1 < rootNote && ( (note1 - rootNote) == (-9) || (note1 - rootNote) == (-4) ||  (note1 - rootNote) == (-2) ) ) ||
        (note2 < rootNote && ( (note2 - rootNote) == (-9) || (note2 - rootNote) == (-4) ||  (note2 - rootNote) == (-2) ) ) ) {
        foundScale = 2; // Minor
        scaleCounter += 1;
      }
    }
    return winner; // 0: no winner  ||  note1  ||  note2;
  }


  public boolean probabilityPS(int note2, int note1) {
    int dist1 = abs(note2 - note1);
    int dist2 = 12 - dist1;
    int distWin;
    int firstNote;
    int winner;
    float ran = random(0, 100);

    if (ran <= probInterval.get(Integer.toString(dist1)+"&"+Integer.toString(dist2))) {
      if (note1 <= note2) {
        distWin = dist1;
        firstNote = note1;
        winner = winning(distWin, firstNote);
      } else {
        distWin = dist1;
        firstNote = note2;
        winner = winning(distWin, firstNote);
      }
    } else {
      if (note1 <= note2) {
        distWin = dist2;
        firstNote = note2;
        winner = winning(distWin, firstNote);
      } else {
        distWin = dist2;
        firstNote = note1;
        winner = winning(distWin, firstNote);
      }
    }
    if (winner != 0) {
      return true;
    } else {
      return false;
    }
  }


  public int winning(int dist, int note) {
    float ran = random(0, 100);
    if (ran <= probWin.get(Integer.toString(dist))) {
      return note;
    } else {
      return 0;
    }
  }


  public Boolean rootNoteSatisfied(int note1, int note2) {
    return
      (  ( ((note1 - rootNote) >= 0 && (note1 - rootNote) != 1 && (note1 - rootNote) != 6) ||
      ((note1 - rootNote) < 0 && (note1 - rootNote) != (-6) && (note1 - rootNote) != (-11)) )
      &&
      ( ((note2 - rootNote) >= 0 && (note2 - rootNote) != 1 && (note2 - rootNote) != 6) ||
      ((note2 - rootNote) < 0 && (note2 - rootNote) != (-6) && (note2 - rootNote) != (-11)) )  );
  }


  public Boolean scaleSatisfied(int note1, int note2) {
    if (foundScale == 1) {
      return
        ( ((note1 - rootNote) >= 0 && (note1 - rootNote) != 1 && (note1 - rootNote) != 3 &&
        (note1 - rootNote) != 6 && (note1 - rootNote) != 8 && (note1 - rootNote) != 10) ||
        ((note1 - rootNote) < 0 && (note1 - rootNote) != (-11) && (note1 - rootNote) != (-9) &&
        (note1 - rootNote) != (-6) && (note1 - rootNote) != (-4) && (note1 - rootNote) != (-2)) )
        &&
        ( ((note2 - rootNote) >= 0 && (note2 - rootNote) != 1 && (note2 - rootNote) != 3 &&
        (note2 - rootNote) != 6 && (note2 - rootNote) != 8 && (note2 - rootNote) != 10) ||
        ((note2 - rootNote) < 0 && (note2 - rootNote) != (-11) && (note2 - rootNote) != (-9) &&
        (note2 - rootNote) != (-6) && (note2 - rootNote) != (-4) && (note2 - rootNote) != (-2)) );
    }
    if (foundScale == 2) {
      return
        ( ((note1 - rootNote) >= 0 && (note1 - rootNote) != 1 && (note1 - rootNote) != 4 &&
        (note1 - rootNote) != 6 && (note1 - rootNote) != 9 && (note1 - rootNote) != 11) ||
        ((note1 - rootNote) < 0 && (note1 - rootNote) != (-11) && (note1 - rootNote) != (-8) &&
        (note1 - rootNote) != (-6) && (note1 - rootNote) != (-3) && (note1 - rootNote) != (-1)) )
        &&
        ( ((note2 - rootNote) >= 0 && (note2 - rootNote) != 1 && (note2 - rootNote) != 4 &&
        (note2 - rootNote) != 6 && (note2 - rootNote) != 9 && (note2 - rootNote) != 11) ||
        ((note2 - rootNote) < 0 && (note2 - rootNote) != (-11) && (note2 - rootNote) != (-8) &&
        (note2 - rootNote) != (-6) && (note2 - rootNote) != (-3) && (note2 - rootNote) != (-1)) );
    } else {
      return false;
    }
  }

  public Boolean scaleSatisfiedForPS (int note1, int note2, int note3) {
    if (foundScale == 1) {
      return
        (
        (note3 != note1)
        &&
        (note3 != note2)
        &&
        ((note3 - rootNote) >= 0 && (note3 - rootNote) != 1 &&
        (note3 - rootNote) != 3 && (note3 - rootNote) != 6 &&
        (note3 - rootNote) != 8 && (note3 - rootNote) != 10)
        ||
        ((note3 - rootNote) < 0 && (note3 - rootNote) != (-11) &&
        (note3 - rootNote) != (-9) && (note3 - rootNote) != (-6) &&
        (note3 - rootNote) != (-4) && (note3 - rootNote) != (-2))
        );
    }
    if (foundScale == 2) {
      return
        (
        (note3 != note1)
        &&
        (note3 != note2)
        &&
        ((note3 - rootNote) >= 0 && (note3 - rootNote) != 1 &&
        (note3- rootNote) != 4 && (note3 - rootNote) != 6 &&
        (note3 - rootNote) != 9 && (note3 - rootNote) != 11)
        ||
        ((note3 - rootNote) < 0 && (note3 - rootNote) != (-11) &&
        (note3 - rootNote) != (-8) && (note3 - rootNote) != (-6) &&
        (note3 - rootNote) != (-3) && (note3 - rootNote) != (-1))
        );
    } else {
      return false;
    }
  }

  // FUNCTIONS TO SEND OSC MESSAGES TO SUPERCOLLIDER

  public void systemsNotesOsc() {
    ArrayList<ArrayList<Float>> n = new ArrayList<ArrayList<Float>>();
    String str = "";
    for (int i = 0; i< globalSystems.size(); i++) {
      n.add(globalSystems.get(i).getNotes());
    }
    for (int j = 0; j<n.size(); j++) {
      str+= n.get(j).toString()+":";
    }
    OscMessage msg = new OscMessage("/values");
    msg.add(str);
    oscP5.send(msg, myRemoteLocation);
  }

  public PVector calculateCenterOfMass() {
    this.totalMass = 0;
    this.centerOfMass = new PVector();
    if (this.divided) {
      for (Octree child : children) {
        PVector childCenter = child.calculateCenterOfMass();
        this.centerOfMass.add(PVector.mult(childCenter, child.totalMass));
        this.totalMass += child.totalMass;
      }
    } else {
      for (Particle p : this.particles) {
        this.centerOfMass.add(PVector.mult(p.position, p.mass));
        this.totalMass += p.mass;
      }
    }
    if (this.totalMass>0) {
      this.centerOfMass.div(this.totalMass);
    }
    return this.centerOfMass;
  }


  public void calculateForce(Particle particle, float threshold) {
    if (this.divided) {
      float distance = PVector.dist(particle.position, this.calculateCenterOfMass());
      float ratio = size / distance;

      if (ratio < threshold) {
        PVector force = calculateForceFromNode(particle);
        particle.applyForce(force);
      } else {
        for (Octree child : children) {
          child.calculateForce(particle, threshold);
        }
      }
    } else {
      for (Particle otherParticle : particles) {
        if (otherParticle != particle) {
          PVector force = calculateForceBetweenParticles(particle, otherParticle);
          particle.applyForce(force);
        }
      }
    }
  }


  public PVector calculateForceFromNode(Particle particle) {
    PVector force = new PVector(0, 0, 0);
    float distance = PVector.dist(particle.position, this.centerOfMass);
    float magnitude = G * (particle.mass * this.totalMass) / (distance * distance);
    PVector direction = PVector.sub(this.centerOfMass, particle.position);
    direction.normalize();
    force = PVector.mult(direction, magnitude);
    return force;
  }


  public PVector calculateForceBetweenParticles(Particle particle1, Particle particle2) {
    PVector force = new PVector(0, 0, 0);
    float distance = PVector.dist(particle1.position, particle2.position);
    float magnitude = G * (particle1.mass * particle2.mass) / (distance * distance);
    PVector direction = PVector.sub(particle2.position, particle1.position);
    direction.normalize();
    force = PVector.mult(direction, magnitude);
    return force;
  }


  public void drawOctree() {
    push();
    noFill();
    stroke(0, 255, 0);
    strokeWeight(0.7f);
    translate(position.x, position.y, position.z);
    box(size);
    pop();
    if (this.divided) {
      for (Octree child : children) {
        child.drawOctree();
      }
    }
  }
}
class Particle {
  PVector position, axRotation, axRotation1, axRotation2;
  float mass, radius = 1, angleAxisRot, scale = 0, time = 80, currentPos = 0;
  PVector velocity;
  PVector force;
  int col;
  PVector k;
  int type; // 1-Planet, 2-Sysytem2, 3-System3
  int note1 = -1, note2 = -1, note3 = -1;
  PShape globe0, globe1, globe2, globe3;
  Boolean impacting;

  //costruttore
  Particle(float x, float y, float z, float mass, int type, int note1, int note2, int note3) {
    this.position = new PVector(x, y, z);
    this.axRotation = new PVector(random(0, TWO_PI), random(0, TWO_PI), random(0, TWO_PI)); // random rotated axis of the single planet
    this.axRotation1 = new PVector(random(0, TWO_PI), random(0, TWO_PI), random(0, TWO_PI)); // random rotated axis of the single planet
    this.axRotation2 = new PVector(random(0, TWO_PI), random(0, TWO_PI), random(0, TWO_PI)); // random rotated axis of the single planet
    this.angleAxisRot = 0; // angle of rotation of planets around their axis
    k = new PVector(1, 1, 1);
    k.normalize();
    this.mass = mass;
    impacting = false;
    this.radius = mass;
    float rot;
    if (random(1)>0.5f) {
      rot = PI/2;
    } else {
      rot = -PI/2;
    }
    velocity = position.copy().rotate(rot);
    float mag = 0;
    if (position.mag()>0) {
      mag = sqrt(massone*G*(2/position.mag() - 1/position.mag()));
    }
    velocity.setMag(mag);
    force = new PVector();

    //Setting the type. 1-Planet, 2-Sysytem2, 3-System3
    this.type = type;
    this.note1 = note1;
    this.note2 = note2;
    this.note3 = note3;

    noStroke();
    if (this.type == 1) {
      globe1 = createShape(SPHERE, this.radius);
      globe1.setTexture(img[this.note1-1]);
    } else if (this.type == 2) {
      globe1 = createShape(SPHERE, this.radius);
      globe1.setTexture(img[this.note1-1]);
      globe2 = createShape(SPHERE, this.radius/1.5f);
      globe2.setTexture(img[this.note2-1]);
      globe3 = createShape(SPHERE, this.radius/2);
    } else if (this.type == 0) {
      this.radius = 70;
      noStroke();
      globe0 = createShape(SPHERE, this.radius);
      globe0.setTexture(img[12]);
    }
  }

  //update particle position
  public void update() {
    velocity.add(force.div(mass));
    position.add(velocity);
    force.mult(0);
  }

  public void setGlobe3(int note) {
    globe3.setTexture(img[note-1]);
  }

  public void applyBruteForce(PVector f) {
    force.add(f);
  }

  public void applyForce(PVector f) {
    f.setMag(constrain(f.mag(), 0, forceConstrain));
    force.add(f);
  }

  public PVector getMomentum() {
    PVector momentum = PVector.mult(velocity, mass);
    return momentum;
  }

  public ArrayList<Float> getNotes() {
    ArrayList notesList = new ArrayList<Float>();
    if (notes.get(this.note1) > notes.get(this.note2)) {
      notesList.add(notes.get(this.note1));
      //notesList.add(notes.get(this.note2)*2);
      notesList.add(notes.get(this.note2)+12);
    } else {
      notesList.add(notes.get(this.note1));
      notesList.add(notes.get(this.note2));
    }
    if (this.note3 != -1) {
      if (notes.get(this.note1) > notes.get(this.note3)) {
        //notesList.add(notes.get(this.note3)*2);
        notesList.add(notes.get(this.note3)+12);
      } else {
        notesList.add(notes.get(this.note3));
      }
    }
    return notesList;
  }
  
  //draw the particle
  public void display() {
    //Draw single Planet
    if (this.type == 1) {
      push();
      translate(position.x, position.y, position.z);
      rotateX(this.axRotation.x);
      rotateY(this.axRotation.y);
      rotateZ(this.axRotation.z);
      rotate(angleAxisRot/60);
      shape(globe1);
      pop();
    }
    //Draw System with one orbiting planet
    else if (this.type == 2) {
      // big planet
      push();
      translate(position.x, position.y, position.z);
      if (this.scale <= (this.time)) {
        scale(this.scale/(this.time));
        this.scale++;
      }
      rotateX(this.axRotation.x);
      rotateY(this.axRotation.y);
      rotateZ(this.axRotation.z);
      rotate(angleAxisRot/60);
      shape(globe1);
      pop();

      angleAxisRot++;

      // little planet 1
      push();
      translate(this.position.x, this.position.y, this.position.z);
      rotateX(this.axRotation1.x);
      rotateY(this.axRotation1.y);
      rotateZ(this.axRotation1.z);
      rotate(angleAxisRot/60);
      push();
      scale(this.scale/(this.time));
      stroke(128, 128, 128);
      noFill();
      circle(0, 0, 2*2.5f*this.mass);
      pop();
      currentPos = lerp(currentPos, 2.5f*this.mass, 0.01f);
      translate(currentPos, 0);
      scale(this.scale/(this.time));
      shape(globe2);
      pop();
    }
    //Draw System with two orbiting planets
    else if (this.type == 3) {
      // big planet
      push();
      translate(position.x, position.y, position.z);
      rotateX(this.axRotation.x);
      rotateY(this.axRotation.y);
      rotateZ(this.axRotation.z);
      rotate(angleAxisRot/60);
      shape(globe1);
      pop();

      angleAxisRot++;

      // little planet 1
      push();
      translate(this.position.x, this.position.y, this.position.z);
      rotateX(this.axRotation1.x);
      rotateY(this.axRotation1.y);
      rotateZ(this.axRotation1.z);
      rotate(angleAxisRot/60);
      push();
      stroke(128, 128, 128);
      noFill();
      circle(0, 0, 2*2.5f*this.mass);
      pop();
      translate(2.5f*this.mass, 0);
      shape(globe2);
      pop();

      //little planet 2

      push();
      translate(this.position.x, this.position.y, this.position.z);
      if (scale <= (time)) {
        scale(scale/(time));
        scale++;
      }
      rotateX(this.axRotation2.x);
      rotateY(this.axRotation2.y);
      rotateZ(this.axRotation2.z);
      rotate(angleAxisRot/60);
      push();
      scale(scale/(time));
      stroke(128, 128, 128);
      noFill();
      circle(0, 0, 2*3*this.mass);
      pop();
      translate(3*this.mass, 0);
      scale(scale/(time));
      shape(globe3);
      pop();
    }
    //Draw buco nero
    else if (this.type == 0) {
      push();
      translate(position.x, position.y, position.z);
      rotateX(this.axRotation.x);
      rotateY(this.axRotation.y);
      rotateZ(this.axRotation.z);
      rotate(angleAxisRot/120);
      //scale(this.radius);
      shape(globe0);
      pop();
    } else println("Error on type draw");
    angleAxisRot++;
  }

  public void higlight() {
    push();
    translate(position.x, position.y, position.z);
    fill(255, 255, 153, 50);
    sphere(250);
    pop();
  }
}
public void init_page() {
  checkpoint = 0;
  
  if (firstTime) {
    noFill();
    img[0] = loadImage("C.png");
    noFill();
    img[1] = loadImage("C#.png");
    noFill();
    img[2] = loadImage("D.png");
    noFill();
    img[3] = loadImage("D#.png");
    noFill();
    img[4] = loadImage("E.png");
    noFill();
    img[5] = loadImage("F.png");
    noFill();
    img[6] = loadImage("F#.png");
    noFill();
    img[7] = loadImage("G.png");
    noFill();
    img[8] = loadImage("G#.png");
    noFill();
    img[9] = loadImage("A.png");
    noFill();
    img[10] = loadImage("A#.png");
    noFill();
    img[11] = loadImage("B.png");
    noFill();
    img[12] = loadImage("fire.png");
    noFill();
    img[13] = loadImage("milky_way3.jpg");
    noFill();
    img[14] = loadImage("Legend.png");
    noFill();
    sx_arr = loadImage("left_arr.png");
    noFill();
    dx_arr = loadImage("right_arr.png");
    noFill();
    sx_arr_on = loadImage("left_arr_on.png");
    noFill();
    dx_arr_on = loadImage("right_arr_on.png");
    
    loaded = true;

    //images (SVG) for Hand recognition
    hand[0] = loadShape("info.svg");
    hand[1] = loadShape("ok_dx.svg");
    hand[2] = loadShape("ok_dx.svg");
    hand[3] = loadShape("palm_dx_off.svg");
    hand[4] = loadShape("palm_sx_off.svg");
    hand[5] = loadShape("one.svg");
    hand[6] = loadShape("one.svg");
    hand[7] = loadShape("two.svg");
    hand[8] = loadShape("two.svg");
    hand[9] = loadShape("three.svg");
    hand[10] = loadShape("three.svg");
    hand[11] = loadShape("four.svg");
    hand[12] = loadShape("four.svg");

    mixerHand[0] = loadShape("one.svg");
    mixerHand[1] = loadShape("two.svg");
    mixerHand[2] = loadShape("three.svg");
    mixerHand[3] = loadShape("four.svg");

    // ok
    hand[1].setFill(color(250, 255, 0)); //Ok R
    hand[2].setFill(color(250, 255, 0));
    hand[2].rotateY(PI);
    hand[2].translate(hand[2].width, 0);  //Ok L
    // palm off
    hand[3].setFill(color(100, 100, 100)); //Palm R
    hand[4].setFill(color(100, 100, 100)); // Palm L
    // One
    hand[5].setFill(color(250, 255, 0)); //One R
    hand[6].setFill(color(250, 255, 0));
    hand[6].rotateY(PI);
    hand[6].translate(hand[6].width, 0);  //One L
    // Two
    hand[7].setFill(color(250, 255, 0)); //Two R
    hand[8].setFill(color(250, 255, 0));
    hand[8].rotateY(PI);
    hand[8].translate(hand[8].width, 0);  //Two L
    //Three
    hand[9].setFill(color(250, 255, 0)); //Three R
    hand[10].setFill(color(250, 255, 0));
    hand[10].rotateY(PI);
    hand[10].translate(hand[10].width, 0);//Three L
    //Four
    hand[11].setFill(color(250, 255, 0)); //Four R
    hand[12].setFill(color(250, 255, 0));
    hand[12].rotateY(PI);
    hand[12].translate(hand[12].width, 0);//Four L
    

    //Mixer hands
    mixerHand[0].setFill(color(255));
    mixerHand[1].setFill(color(255));
    mixerHand[2].setFill(color(255));
    mixerHand[3].setFill(color(255));

    hand[1].setVisible(false);
    hand[2].setVisible(false);
    hand[3].setVisible(true);
    hand[4].setVisible(true);
    hand[5].setVisible(false);
    hand[6].setVisible(false);
    hand[7].setVisible(false);
    hand[8].setVisible(false);
    hand[9].setVisible(false);
    hand[10].setVisible(false);
    hand[11].setVisible(false);
    hand[12].setVisible(false);

    mixerHand[0].setVisible(true);
    mixerHand[1].setVisible(true);
    mixerHand[2].setVisible(true);
    mixerHand[3].setVisible(true);

// PROBABILITY

    // This prob matrix controls which interval between 2 colliding notes will be taken into account
    // Coded as: ("internal_interval & external_interval", number)
    // ran = random(0,100) 
    // if (ran < number) ==> internal_interval is the chosen one
    // if (ran > number) ==> external_interval is the chosen one
    probInterval.put("0&12", 50);
    probInterval.put("1&11", 5);
    probInterval.put("2&10", 6);
    probInterval.put("3&9", 90);
    probInterval.put("4&8", 95);
    probInterval.put("5&7", 25);
    probInterval.put("6&6", 50);
    probInterval.put("7&5", 75);
    probInterval.put("8&4", 5);
    probInterval.put("9&3", 10);
    probInterval.put("10&2", 94);
    probInterval.put("11&1", 95);
    probInterval.put("12&0", 50);

    // This prob matrix controls if the collision happens or not, 
    // basing this choice on the chosen distance between the notes
    // Coded as: ("chosen_interval", number)
    // ran = random(0,100) 
    // if (ran < number) ==> the collision happens
    // if (ran > number) ==> the two colliding planets ingore each other
    probWin.put("0", 0);   // unisono
    probWin.put("1", 0);   // seconda minore
    probWin.put("2", 5);   // seconda maggiore
    probWin.put("3", 95);  // terza minore
    probWin.put("4", 95);  // terza maggiore
    probWin.put("5", 70);  // quarta giusta
    probWin.put("6", 0);   // quinta diminuita
    probWin.put("7", 90);  // quinta
    probWin.put("8", 25);  // sesta minore
    probWin.put("9", 25);  // sesta maggiore
    probWin.put("10", 70); // settima maggiore
    probWin.put("11", 70); // settima minore
    probWin.put("12", 0);  // ottava

    notes.put(1, 60); //midi code
    notes.put(2, 61);
    notes.put(3, 62);
    notes.put(4, 63);
    notes.put(5, 64);
    notes.put(6, 65);
    notes.put(7, 66);
    notes.put(8, 67);
    notes.put(9, 68);
    notes.put(10, 69);
    notes.put(11, 70);
    notes.put(12, 71);
    
    midiToNote.put(60, "C");
    midiToNote.put(61, "C#");
    midiToNote.put(62, "D");
    midiToNote.put(63, "D#");
    midiToNote.put(64, "E");
    midiToNote.put(65, "F");
    midiToNote.put(66, "F#");
    midiToNote.put(67, "G");
    midiToNote.put(68, "G#");
    midiToNote.put(69, "A");
    midiToNote.put(70, "A#");
    midiToNote.put(71, "B");
    midiToNote.put(72, "C");
    midiToNote.put(73, "C#");
    midiToNote.put(74, "D");
    midiToNote.put(75, "D#");
    midiToNote.put(76, "E");
    midiToNote.put(77, "F");
    midiToNote.put(78, "F#");
    midiToNote.put(79, "G");
    midiToNote.put(80, "G#");
    midiToNote.put(81, "A");
    midiToNote.put(82, "A#");
    midiToNote.put(83, "B");

    f = createFont("Arial", 128, true);
    f4 = createFont("Arial", 128, true);
    f5 = createFont("Arial", 18, true);
    scaleName.put(0, " ");
    scaleName.put(1, "C");
    scaleName.put(2, "C#");
    scaleName.put(3, "D");
    scaleName.put(4, "D#");
    scaleName.put(5, "E");
    scaleName.put(6, "F");
    scaleName.put(7, "F#");
    scaleName.put(8, "G");
    scaleName.put(9, "G#");
    scaleName.put(10, "A");
    scaleName.put(11, "A#");
    scaleName.put(12, "B");
    
    scaleType.put(0, " ");
    scaleType.put(1, "maj");
    scaleType.put(2, "min");

    firstTime = false;
  }

  checkpoint++;

  count = 0;
  depth = 500;

  position = new PVector(0, 0, 0);
  size = 1000;
  sizeMax=size;
  octree = new Octree(position, octreeCap, size);
  globalParticles = new ArrayList<Particle>();
  globalSystems = new ArrayList<Particle>();
  leaves = new ArrayList<Octree>();

  checkpoint++;

  centerOfMass = new PVector();

  loaded = false;
  push();
  //La prima particella è il buco nero
  for (int i = 0; i < nPlan; i++) {
    if ( i == 0) {
      PVector pos = new PVector(0, 0, 0);
      float mass = massone;
      Particle particle = new Particle(pos.x, pos.y, pos.z, massone, 0, -1, -1, -1);
      globalParticles.add(particle);
      octree.addParticle(particle);
    } else {
      PVector pos = PVector.random3D().mult(random(500, 2000));
      pos.z = constrain(pos.z, -300 + random(-100,0), 300 + random(0,100));
      float mass = random(minMass, maxMass);
      int note1 = PApplet.parseInt(random(1, 13));
      noStroke();
      noFill();
      Particle particle = new Particle(pos.x, pos.y, pos.z, mass, 1, note1, -1, -1);
      globalParticles.add(particle);
      octree.addParticle(particle);
    }
  }
  pop();
  loaded = true;

  nLead_old = new ArrayList<Float>();

  checkpoint++;

  setupMixer();

  checkpoint++;

  delay(4000); // Lengthly initialization here: load stuff, compute things, etc.
  checkpoint++; //5
  delay(1000);
  startPhase++;
}

public void showLoading() {
  background(0);
  cam.beginHUD();
  image(img_load, width/2 - 529, height/2-200);
  if (loaded) {
    image(img_loading[checkpoint], width/2 -500, height/2 +200);
  }
  cam.endHUD();
}

public void homePage() {
  octreeDrawable = false;
  cam.setActive(false);
  img[13].resize(width, height);
  background(img[13]);
  lights();
  for (Particle p : globalParticles) {
    p.display();
  }
  cam.rotateY((double)(PI/70));
  if (started == false && oneTime) {
    cam.beginHUD();
    push();
    image(img_home, width/2 - 433, height/2);
    pop();
    cam.endHUD();
    if (keyPressed) {
      if (key == ' ' && oneTime) {
        oneTime = false;
        cam.reset(2000);
        cam.setDistance(5000, 2000);
        thread("threadStart");
      }
    }
  }
}

public void threadStart() {
  delay(2000);
  started = true;
  cam.setActive(true);
  startPhase++;
}


  public void settings() { size(1440, 900, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "CelestialVibesPDE" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
